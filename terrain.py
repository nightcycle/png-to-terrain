import hashlib
import toml
import base64
import json
from typing import TypedDict
from bitstring import BitArray

material_color_bin_str = """![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]"""

phys_grid_bin_str = """![CDATA[AgMAAAAE//8A//8A//8A//8BAAAAAAAAAAAAAAEAAP8AAP8AAP8AAf8AAAAAAAAAAAAAAAEA
AAAAAAAAAAA="""

smooth_grid_bin_str = """![CDATA[AQUAAAAAAAAAAAAAAACA/4AfAoAJAkJNgBICQldCMoAHQplCgIASAkKegguA/4D/gP+AvMJN
AYAdQoBCmYAUQgSAB4IBgP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A
/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A
/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A
/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A
/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4D/gP+A/4CS]]"""

def get_bytes_from_binary_str(bin_str: str) -> bytes:
	clean_data = bin_str.replace('![CDATA[', '').replace(']]', '').replace('\n', '').strip()
	return base64.b64decode(clean_data)

def get_bit_str_from_bytes(b: bytes) -> str:
	return bin(b)[2:]


def decode_binary_string(bin_str: str) -> list[int]:
	# Remove the CDATA tag and any newlines/whitespace
	output = []
	for b in get_bytes_from_binary_str(bin_str):
		output.append(int.from_bytes(bytes([b]), 'big'))

	return output

# 01000001 01010001 01010101 01000001 01000001 01000001 01000001 01000001 
# 01000001 01000001 01000001 01000001 01000001 01000001 01000001 01000001 
# 01000001 01000001 01000011 01000001 00101111 00110100 01000001 01100110 
# 01000001 01101111 01000001 01001010 01000001 01101011 01001010 01001110 
# 01100111 01000010 01001001 01000011 01010001 01101100 01100100 01000011 
# 01001101 01101111 01000001 01001000 01010001 01110000 01101100 01000011 
# 01100111 01001001 01000001 01010011 01000001 01101011 01001011 01100101
# 01100111 01100111 01110101 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 01110110 01001101 01001010 01001110 
# 00001010 01000001 01011001 01000001 01100100 01010001 01101111 01000010 
# 01000011 01101101 01011001 01000001 01010101 01010001 01100111 01010011 
# 01000001 01000010 00110100 01001001 01000010 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00101111 00110100 01000100 00101111 01100111 01010000 00101011 
# 01000001 00001010 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00101111 00110100 01000100 00101111 01100111 01010000 
# 00101011 01000001 00001010 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00101111 00110100 01000100 00101111 01100111 
# 01010000 00101011 01000001 00001010 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00101111 00110100 01000100 00101111 
# 01100111 01010000 00101011 01000001 00001010 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000100 
# 00101111 01100111 01010000 00101011 01000001 00101111 00110100 01000011 
# 01010011

def decode_material_colors(binary_str: str) -> dict[str: str]:
	colors = []
	color_values = decode_binary_string(binary_str)
	mat_order = [
		"Air",
		"Water",
		"Grass",
		"Slate",
		"Concrete",
		"Brick",
		"Sand",
		"WoodPlanks",
		"Rock",
		"Glacier",
		"Snow",
		"Sandstone",
		"Mud",
		"Basalt",
		"Ground",
		"CrackedLava",
		"Asphalt",
		"Cobblestone",
		"Ice",
		"LeafyGrass",
		"Salt",
		"Limestone",
		"Pavement",			
	]
	for i, val in enumerate(color_values):
		if round(i/3) == i/3 and i+2 <= len(color_values):
			r = val
			g = color_values[i+1]
			b = color_values[i+2]
			colors.append([r,g,b])

	def rgb_to_hex(rgb):
		return '%02x%02x%02x' % rgb

	color_registry = {}
	for i, color in enumerate(colors):
		if i > 1:
			key = mat_order[i]
			hex_val = rgb_to_hex((color[0], color[1], color[2]))
			color_registry[key] = hex_val

	return color_registry

# get material colors
# print(json.dumps(decode_material_colors(material_color_bin_str), indent=4))

# get smooth grid https://zeux.io/2017/03/27/voxel-terrain-storage/
smooth_grid_values = decode_binary_string(smooth_grid_bin_str)
print(smooth_grid_values)
